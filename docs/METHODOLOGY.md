# ADE Methodology\r\n\r\n**The Executable Lifecycle of Axiom Driven Engineering**\r\n\r\n---\r\n\r\n## Overview\r\n\r\nThe ADE methodology transforms axioms into working software through a structured lifecycle. Each phase produces artifacts that trace back to governing principles.\r\n\r\n```mermaid\r\ngraph LR\r\n    R[Requirements] --> S[Specify]\r\n    S --> C[Clarify]\r\n    C --> P[Plan]\r\n    P --> T[Tasks]\r\n    T --> I[Implement]\r\n    I --> V[Verify]\r\n    V --> A[Analyze]\r\n    A -.-> S\r\n```\r\n\r\n---\r\n\r\n## Phase 1: Specify\r\n\r\n**Goal**: Define WHAT and WHY  \r\n**Governing Postulate**: Π.1.1, Π.1.2\r\n\r\n### Inputs\r\n- User requirements or problem statement\r\n- Domain constraints\r\n- Stakeholder feedback\r\n\r\n### Process\r\n0. **Verify Axiom Acceptance** — Ensure both Human and AI participants have accepted the core axioms\r\n1. **Establish User Scenarios** — Define behavioral expectations via Given/When/Then\r\n2. **Commit Scenarios** — Scenarios MUST be committed to the specification before any tests are defined\r\n3. **Define Functional Requirements** — Derived from committed scenarios\r\n4. **Identify Constraints** — Performance, security, and infrastructure boundaries\r\n5. **Document Assumptions & Risks**\r\n\r\n### Outputs\r\n- `.specify/specs/{feature}/spec.md`\r\n\r\n### Spec.md Template\r\n```markdown\r\n# {Feature Name} Specification\r\n\r\n## User Stories\r\n### [US-1] {Story Title}\r\n**As a** {role}\r\n**I want** {capability}\r\n**So that** {benefit}\r\n\r\n#### Acceptance Criteria\r\n- [ ] Given {context}, When {action}, Then {outcome}\r\n\r\n## Functional Requirements\r\n- [FR-1] {Requirement}\r\n\r\n## Non-Functional Requirements\r\n- [NFR-1] {Requirement}\r\n\r\n## Assumptions\r\n- {Assumption}\r\n\r\n## Risks\r\n- {Risk}\r\n```\r\n\r\n---\r\n\r\n## Phase 2: Clarify\r\n\r\n**Goal**: Resolve ambiguities  \r\n**Governing Postulate**: Π.1.1a (requirements documented)\r\n\r\n### Process\r\n1. Review specification with stakeholders\r\n2. Identify unclear requirements\r\n3. Ask clarifying questions\r\n4. Update specification with answers\r\n5. Repeat until spec is unambiguous\r\n\r\n### Three-Cycle Rule\r\nADE mandates a minimum of 3 clarification cycles:\r\n\r\n| Cycle | Focus                               |\r\n| ----- | ----------------------------------- |\r\n| 1     | Terminology and scope               |\r\n| 2     | Edge cases and error handling       |\r\n| 3     | Integration points and dependencies |\r\n\r\n---\r\n\r\n## Phase 3: Plan\r\n\r\n**Goal**: Define HOW  \r\n**Governing Postulate**: Π.3.1, Π.4.1\r\n\r\n### Inputs\r\n- Clarified specification\r\n- Project constitution\r\n- Existing architecture\r\n\r\n### Process\r\n1. Select technology choices\r\n2. Design component architecture\r\n3. Define API contracts\r\n4. Create ADRs for significant decisions\r\n5. Constitutional compliance check\r\n\r\n### Outputs\r\n- `.specify/specs/{feature}/plan.md`\r\n- `docs/decisions/XXXX-{decision}.md` (as needed)\r\n\r\n### Plan.md Template\r\n```markdown\r\n# {Feature Name} Implementation Plan\r\n\r\n## Overview\r\n{Brief description of technical approach}\r\n\r\n## Technology Choices\r\n| Component   | Choice | Justification | ADR      |\r\n| ----------- | ------ | ------------- | -------- |\r\n| {Component} | {Tech} | {Why}         | ADR-XXXX |\r\n\r\n## Architecture\r\n{Component diagram or description}\r\n\r\n## API Contracts\r\n### {Endpoint/Interface}\r\n- Method: {GET/POST/etc}\r\n- Path: {/path}\r\n- Request: {schema}\r\n- Response: {schema}\r\n\r\n## Constitutional Compliance\r\n- [ ] Π.2.1: Test strategy defined\r\n- [ ] Π.4.1: Single responsibility per component\r\n- [ ] Π.4.1a: No circular dependencies\r\n```\r\n\r\n---\r\n\r\n## Phase 4: Tasks\r\n\r\n**Goal**: Define WHEN and WHERE  \r\n**Governing Postulate**: Π.1.2a, Π.4.1\r\n\r\n### Process\r\n1. Decompose plan into atomic tasks\r\n2. Identify dependencies\r\n3. Order by: Infrastructure → Models → Services → Endpoints → UI\r\n4. Mark parallelizable tasks\r\n5. Estimate effort\r\n\r\n### Task Notation\r\n```\r\n[P] — Parallelizable with previous [P] task\r\n[Bx] — Blocked by task x\r\n[USx] — Implements User Story x\r\n```\r\n\r\n### Outputs\r\n- `.specify/specs/{feature}/tasks.md`\r\n\r\n### Tasks.md Template\r\n```markdown\r\n# {Feature Name} Task Breakdown\r\n\r\n## Phase 1: Setup\r\n- [ ] 1. {Task} `[P]`\r\n- [ ] 2. {Task} `[P]`\r\n\r\n## Phase 2: Foundation\r\n- [ ] 3. {Task} `[B1,B2]`\r\n- [ ] 4. {Task} `[US-1]`\r\n\r\n## Phase 3: Implementation\r\n- [ ] 5. {Task} `[US-1]`\r\n- [ ] 6. {Task} `[US-2]` `[P]`\r\n\r\n## Phase 4: Polish\r\n- [ ] 7. {Task} `[B5,B6]`\r\n```\r\n\r\n---\r\n\r\n## Phase 5: Implement\r\n\r\n**Goal**: Execute the plan  \r\n**Governing Postulate**: Π.2.1, Π.2.2\r\n\r\n### The Mandatory Pipeline\r\n**No implementation code shall be written until a failing test exists in the codebase.**\r\n\r\n1. **BDD Verification**: Review committed User Scenarios from phase 1.\r\n2. **RED Commit (Test-First)**\r\n   - Define a test that verifies a specific acceptance criterion.\r\n   - Run the test and confirm it fails.\r\n   - Commit: `test: add failing test for [Scenario ID]`\r\n   \r\n3. **GREEN Commit (Implementation)**  \r\n   - Write the MINIMUM code necessary to make the test pass.\r\n   - Commit: `feat: implement [Scenario ID]`\r\n   \r\n4. **REFACTOR Commit (Standardization)**\r\n   - Clean up code while maintaining green status.\r\n   - Commit: `refactor: [description]`\r\n\r\n### Commit Message Format\r\n```\r\ntype(scope): description\r\n\r\n[optional body]\r\n\r\nRefs: spec/{feature}/spec.md\r\nPostulate: Π.X.Y\r\n```\r\n\r\n### Types\r\n- `feat` — New feature\r\n- `fix` — Bug fix\r\n- `test` — Adding tests\r\n- `refactor` — Non-behavioral change\r\n- `docs` — Documentation\r\n- `chore` — Maintenance\r\n\r\n---\r\n\r\n## Phase 6: Verify\r\n\r\n**Goal**: Confirm implementation matches specification  \r\n**Governing Postulate**: Π.2.1, Π.5.1b\r\n\r\n### Verification Checklist\r\n- [ ] All acceptance criteria pass\r\n- [ ] Test coverage meets thresholds\r\n- [ ] No regressions in existing tests\r\n- [ ] UI matches design (screenshot artifacts)\r\n- [ ] Performance within bounds\r\n- [ ] Security scan passes\r\n\r\n### AI Verification\r\nFor AI-assisted implementation:\r\n- [ ] Agent produced verification artifacts\r\n- [ ] Human reviewed critical paths\r\n- [ ] Spec traceability confirmed\r\n\r\n---\r\n\r\n## Phase 7: Analyze\r\n\r\n**Goal**: Learn and improve  \r\n**Governing Postulate**: Π.3.1\r\n\r\n### Post-Implementation Review\r\n1. What went well?\r\n2. What could improve?\r\n3. Were estimates accurate?\r\n4. Should any postulates be refined?\r\n\r\n### Outputs\r\n- Updated knowledge base\r\n- Process improvement suggestions\r\n- New ADRs if lessons warrant architectural change\r\n\r\n---\r\n\r\n## Quick Reference\r\n\r\n| Phase     | Question      | Output         | Key Postulate |\r\n| --------- | ------------- | -------------- | ------------- |\r\n| Specify   | What & Why?   | spec.md        | Π.1.1         |\r\n| Clarify   | Ambiguous?    | Updated spec   | Π.1.1a        |\r\n| Plan      | How?          | plan.md + ADRs | Π.3.1         |\r\n| Tasks     | When & Where? | tasks.md       | Π.1.2a        |\r\n| Implement | Build it      | Code + Tests   | Π.2.1, Π.2.2  |\r\n| Verify    | Does it work? | Evidence       | Π.5.1b        |\r\n| Analyze   | What learned? | Knowledge      | Π.3.1         |\r\n\r\n---\r\n\r\n**Version**: 1.0.0 | **Established**: 2026-02-06\r\n